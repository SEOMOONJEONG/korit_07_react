## React Hook
Hook 개념은 React version 16.8 부터 도입되었습니다. 얘를 이용하면 함수 컴포넌트에서 상태와 리액트의 다른 기능을 이용 가능합니다.(예전에는 class 컴포넌트 방식으로만 가능했습니다.)
얘가 Hook이라는 것을 명시하기 위한 중요한 규칙들이 몇 가지가 있습니다.

1. 리액트 함수 컴포넌트의 최상위 수준에서 Hook을 호출해야 합니다.
2. 반복문, 조건문, 중첩 함수 내에서 훅을 호출해서는 안된다.(1을 풀이한겁니다.)
3. Hook은 함수기 때문에 동사로 시작하는데, use로 시작하고, 그 뒤에 훅을 사용하는 목적이 따라옵니다.

### useState
1. Counter 라는 컴포넌트를 생성하시오.
2. App.jsx의 return 부분을 전부 다 비우고 Counter 컴포넌트만 삽입하시오.
3. Counter 컴포넌트의 return문은
```jsx
return (<div></div>);
```
로 고정해두겠습니다.

```jsx
import { useState } from "react";

function Counter() {
  // 초기값이 0인 상태를 선언.
  const [ count, setCount ] = useState(0);


  return (
  <div>
    <p>버튼 클릭 횟수 = {count}</p>
    <button onClick={() => setCount(count + 1)}>
      증가
    </button>
  </div>

);

}

export default Counter
```

* 참고 사항
html 태그 내에서의 onclick은 전체 소문자인데 반해서 React 상에서의 _이벤트 이름_ 은 카멜 케이스로 작성해야 합니다. → onClick

함수는 이벤트 핸들러에 전달되어야 하며, 사용자가 버튼을 클릭할 때만 함수를 호출한다는 점을 기억하셔야 합니다. 이상의 경우 화살표 함수를 사용했는데, 이는 코드를 더 압축적으로 사용할 수 있으며, 그에 따라 코드 가독성이 개선되기 때문입니다. 그런데 이벤트 핸들러 안에서 함수를 호출하면 컴포넌트가 렌더링 될 때 함수가 호출되어 무한 루프가 발생할 가능성이 있습니다.

```jsx
// 함수가 버튼을 눌렀을 때에 호출되는 예시
<button onClick={() => setCount(count + 1)}> 증가 {count} </button> // → 함수 자체를 대입

// 함수가 렌더링 중에 호출되는 예시 → 무한 루프 걸릴 가능성 있음
<button onClick={setCount(count + 1)}> 증가 {count} </button> // → 함수의 결과값을 대입
```
const count = 0;
console.log(count); // 결과값이 0
count = setCount(count + 1) // 이 부분에서 1이라는 값이 count 상수에 대입되었다고 볼 수 있네요.
console.log(count); // 결과값이 1

### 일괄처리(Batching)
React 상에서는 상태 업데이트에서 일괄처리를 이용하여 리렌더링을 줄입니다. React 18 이전에는 일괄 처리가 버튼 클릭과 같은 브라우저 이벤트 중에 업데이트 되는 상태에서만 가능했었습니다.

1. MyComponent3 생성
2. App에 MyComponent3 컴포넌트를 삽입하여 main → App → MyComponent3로 이어지는 Tree Structure로 구현하여, npm run dev를 실행 시켜 빈 화면을 띄우시오.
3. count / count2 라는 상태(State)를 선언하고, 각 값을 0으로 초기화 하시오.
4. return 문은 이하와 같습니다.
```jsx
return(
  <>
    <p>현재 값 : {count} 😄 {count2}</p>
    <button onClick={}> 증가 </button>
  </>
)
```

```jsx
import { useState } from "react";

function MyComponent3() {

  const [count1, setCount1] = useState(0);

  const increment = () => {
    setCount1(count1 + 1); 
    setCount1(count1 + 1); 
    setCount1(count1 + 1); 
    setCount1(count1 + 1); 
    setCount1(count1 + 1); 
  }

  return(
  <>
    <p>현재 값 : {count1} ⭐</p>
    <button onClick={increment}> 증가 </button>
  </>
  );
}

export default MyComponent3
```

이상까지의 정리를 바탕으로 했을 때, Counter 컴로넌트에 이하와 같이 increment 함수를 정의한다면, 버튼을 한 번 눌렀을 때 +5 씩 증가하는 것이 아니라 +1 씩 증가합니다.
일괄처리를 한다고 했다면, 값이 +1씩 다섯 번이 이루어지는게 아니라 적어도 +5가 한번에 되어야 한다는 것을 의미합니다.

근데 +1이 한 번만 적용되는 결과가 나왔습니다. 그 부분에 주목하셔야 합니다.

상태 업데이트는 일괄처리의 개념과 함께 _비동기적으로_ 이루어진다는 점에 주목하셔야 합니다.

즉, 상태 업데이트 이전에 그 다음 함수가 호출되어버렸기 때문에ㅐ,
count = 0 인 상태에서 + 1 하기 전에 그 다음 setCount()가 호출되었기 때문에 여전히 count의 값이 0에서 + 1 한 값이 나오려고 했는데 또 그 값이 업데이트 되기 이전에 다음 함수가 호출되고 ... + 5 하는 바람에 결과적으로 버튼 한 번 눌렀을 때 0 + 1 에 해당하는 함수가 다섯 번 호출되어 결과값이 1 이 나왔습니다.
```jsx
import { useState } from "react";

function Counter() {
  // 초기값이 0인 상태를 선언.
  const [ count, setCount ] = useState(0);

  const increment = () => {
    setCount(preCount => preCount + 1);
    setCount(preCount => preCount + 1);
    setCount(preCount => preCount + 1);
    setCount(preCount => preCount + 1);
    setCount(preCount => preCount + 1);
  }

  return (
  <div>
    <p>버튼 클릭 횟수 = {count}</p>
    <button onClick={increment}>
      증가 {count}
    </button>
  </div>

);

}

export default Counter
```
그렇다면 이상의 문제를 해결하기 위해서는 상태 값을 명확하게 조회한 다음에 조회한 값에서 + 1을 시켜주면 되겠네요.